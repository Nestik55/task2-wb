package pattern

import "fmt"

/*
				Реализовать паттерн «стратегия».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
		https://en.wikipedia.org/wiki/Strategy_pattern
*/

/*
	1) Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них
	в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.
	2) Данный паттерн применим в следующих случаях:
	- Когда нужно использовать разные вариации какого-то алгоритма внутри одного объекта;
	- Когда у есть множество похожих классов, отличающихся только некоторым поведением;
	- Когда не хочется показывать детали реализации алгоритмов для других классов;
	- Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора.
	Каждая ветка такого оператора представляет собой вариацию алгоритма;
	3) Плюсы:
	- Горячая замена алгоритмов на лету;
	- Изолирует код и данные алгоритмов от остальных классов;
	- Уход от наследования к делегированию;
	- Реализует принцип открытости/закрытости.
	4) Минусы:
	- Усложняет программу за счёт дополнительных классов;
	- Клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую.
	5) Реальный примеры использования:
	- Библиотека sort использует паттерн "Стратегия" для сортировки данных. Она позволяет пользователям определять свою собственную
	стратегию сортировки, реализуя интерфейс sort.Interface, который требует методов Len, Less и Swap;
	- Пакет context реализует паттерн "Стратегия" в том контексте, что он позволяет пользователям определять
	логику отмены и таймауты при выполнении длительных операций.
*/

// Стратегия
type Strategy interface {
	execute(data string)
}

// Конкретная стратегия 1
type Strategy1 struct{}

func (s *Strategy1) execute(data string) {
	fmt.Println("Strategy1 do " + data)
}

// Конкретная стратегия 2
type Strategy2 struct{}

func (s *Strategy2) execute(data string) {
	fmt.Println("Strategy2 do " + data)
}

type Context struct {
	s Strategy
}

func (c *Context) setStrategy(s Strategy) {
	c.s = s
}

func (c *Context) execute(data string) {
	c.s.execute(data)
}

func CheckStrategy() {
	s1 := &Strategy1{}
	s2 := &Strategy2{}

	c := &Context{}

	c.setStrategy(s1)
	c.execute("something1")

	c.setStrategy(s2)
	c.execute("something2")
}

/*
	Вывод:
Strategy1 do something1
Strategy2 do something2
*/
