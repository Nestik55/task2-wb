package pattern

import "fmt"

/*
			Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
		https://en.wikipedia.org/wiki/Factory_method_pattern
*/

/*
	1) Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов
	в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
	2) Паттерн "Фадричный метод" применим в следующих ситауциях:
	- Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать код;
	- Когда нужно дать возможность пользователям расширять части вашего фреймворка или библиотеки;
	- Когда хочется экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.
	3) Плюсы:
	- Избавляет класс от привязки к конкретным классам продуктов;
	- Выделяет код производства продуктов в одно место, упрощая поддержку кода;
	- Упрощает добавление новых продуктов в программу;
	- Реализует принцип открытости/закрытости.
	4) Минусы:
	- Может привести к созданию больших параллельных иерархий классов,
	так как для каждого класса продукта надо создать свой подкласс создателя.
	5) В качестве реальных примеров использования данного паттерна можно привести следующие:
	- Пакет database/sql, который использует паттерн фабричного метода для создания соединений с базами данных;
	- Пакет net/http, который использует данный паттерн для создания различных обработчиков (handlers) для HTTP-запросов;
	- Пакеты для кодирования и декодирования (например, encoding/json, encoding/xml) могут также рассматриваться как использующие
	фабричный метод, поскольку они предоставляют функции для создания объектов (например, структуры) из данных различных форматов.
*/

/*
	Реализуем данный паттерн на примере создания объектов животных.
*/

// Интерфейс продукта
type Animal interface {
	setSound(sound string)
	getSound()
}

// Конкретный продукт 1
type Dog struct {
	Sound string
}

func (d *Dog) setSound(s string) {
	fmt.Println("set sound for dog")
	d.Sound = s
}

func (d *Dog) getSound() {
	fmt.Print("get sound for dog: ")
	fmt.Println(d.Sound)
}

// Конкретный продукт 2
type Cat struct {
	Sound string
}

func (c *Cat) setSound(s string) {
	fmt.Println("set sound for cat")
	c.Sound = s
}

func (c *Cat) getSound() {
	fmt.Print("get sound for cat: ")
	fmt.Println(c.Sound)
}

// Интерфейс фабрики
type Factory interface {
	Create() Animal
}

// Конкретная фабрика 1
type DogFactory struct{}

func (f *DogFactory) Create() Animal {
	d := &Dog{}
	d.setSound("Gaw")
	return d
}

// Конкретная фабрика 2
type CatFactory struct{}

func (f *CatFactory) Create() Animal {
	c := &Cat{}
	c.setSound("Mow")
	return c
}

// Клиенсткий код
func CheckFactoryMethod() {
	df := &DogFactory{}
	dog := df.Create()
	dog.getSound()

	cf := &CatFactory{}
	cat := cf.Create()
	cat.getSound()
}

/*
	Вывод:
set sound for dog
get sound for dog: Gaw
set sound for cat
get sound for cat: Mow
*/
